const PDFIX_WASM = require("./bin/node/pdfix_wasm.js");

class Pdfix {

  constructor() { }

  pdfixWasm;

  async loadPdfixSdk(binaryPath = null) {
    let options = {};
    if (binaryPath) {
      options.locateFile = (path) => {
        return binaryPath + path;
      }
    }
    this.pdfixWasm = await PDFIX_WASM(options);
    this.pdfixWasm.GetPdfix = () => {
      return this.pdfixWasm.wrapPointer(this.pdfixWasm._GetPdfix(), this.pdfixWasm.Pdfix);
    }
    this.pdfixWasm.allocArray = (typedArray) => {
      var numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
      var ptr = this.pdfixWasm._malloc(numBytes);
      var heapBytes = new Uint8Array(this.pdfixWasm.HEAPU8.buffer, ptr, numBytes);
      heapBytes.set(new Uint8Array(typedArray.buffer));
      return [heapBytes.byteOffset, typedArray.length];
    };
    this.pdfixWasm.allocString = (string) => {
      const bufSize = this.pdfixWasm.lengthBytesUTF32(string);
      var buffer = this.pdfixWasm._malloc(bufSize + 4);
      this.pdfixWasm.stringToUTF32(string, buffer, bufSize + 4);
      return [buffer, string.length];
    }
    return this.pdfixWasm;
  }

  getPdfixSdk() {
    return this.pdfixWasm;
  }

  openDocumentFromPath(path) {
    const fs = require("fs");
    const buffer = new Uint8Array( fs.readFileSync(path, null).buffer );
    return this.openDocumentFromBuffer(buffer);
  }

  async openDocumentFromUrl(url) {
    try {
      const response = await fetch(url, {
        headers: {
          "Accept": "application/octet-stream"
        }
      });
      if (!response.ok) {
        throw new Error(`Network response was not ok: ${response.status} - ${response.statusText}`);
      }
      const buffer = await response.arrayBuffer();
      return this.openDocumentFromBuffer(new Uint8Array(buffer));
    } catch (error) {
      throw new Error(`Fetch failed: ${error.message}`);
    }
  }

  openDocumentFromBuffer(fileBuffer, password = "") {
    const pdfix = this.pdfixWasm.GetPdfix();
    const memStream = pdfix.CreateMemStream();
    const [buffer, size] = this.pdfixWasm.allocArray(fileBuffer);
    memStream.Write(0, buffer, size);
    const pdfDoc = pdfix.OpenDocFromStream(memStream, password);
    return pdfDoc;
  }

  renderPage(pdfDoc, pageNumber = 0, zoom = 1, rotation = 0, box = null) {
    const pdfix = this.pdfixWasm.GetPdfix();
    const pdfPage = pdfDoc.AcquirePage(pageNumber);
    const pageView = pdfPage.AcquirePageView(zoom, rotation);

    const devWidth = pageView.GetDeviceWidth();
    const devHeight = pageView.GetDeviceHeight();

    const clipRect = new this.pdfixWasm.PdfDevRect();
    if (box) {
      clipRect.left = box.left;
      clipRect.top = box.top;
      clipRect.right = box.right;
      clipRect.bottom = box.bottom;
    }

    const clipBox = new this.pdfixWasm.PdfRect();
    if (!(clipRect.left == 0 && clipRect.right == 0 &&
      clipRect.top == 0 && clipRect.bottom == 0)) {
      devWidth = clipRect.right - clipRect.left;
      devHeight = clipRect.bottom - clipRect.top;
      pageView.RectToPage(clipRect, clipBox);
    }

    const image = pdfix.CreateImage(devWidth, devHeight, this.pdfixWasm.kImageDIBFormatArgb);

    const params = new this.pdfixWasm.PdfPageRenderParams();
    params.image = image;
    params.clip_box = clipBox;
    params.redner_flags = this.pdfixWasm.kRenderAnnot;
    pageView.GetDeviceMatrix(params.matrix);
    pdfPage.DrawContent(params, null, null);
    
    const img_params = new this.pdfixWasm.PdfImageParams();
    img_params.format = this.pdfixWasm.kImageFormatPng;

    const mem = pdfix.CreateMemStream();
    image.SaveToStream(mem, img_params);

    const pic = this.pdfixWasm._malloc(mem.GetSize());
    mem.Read(0, pic, mem.GetSize());
    
    const buffer = new ArrayBuffer(mem.GetSize())
    mem.ReadToArrayBuffer(0, buffer, buffer.byteLength)

    pdfPage.Release();
    pageView.Release()
    image.Destroy();
    mem.Destroy();
    
    return new Blob([buffer], { type: 'image/png' })
  }

}

module.exports = Pdfix;